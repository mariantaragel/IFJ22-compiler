/* Pravděpodobně zde nemusí být, pokud prolog a uzavírací značka nebudou tokeny z lex. analýzy
	<program> -> <prolog> <program_body> <ending_symbol>
	<prolog> -> <?php declare(strict_types=1);
	<ending_symbol> -> ?> | e 
*/

<program_body> -> <func> <program_body> | <stmt_list> <program_body> | e		
	
	<stmt_list> -> <stmt> <stmt_list> | e

		<stmt> -> if ( <exp> ) { <stmt_list> } else { <stmt_list> }
		<stmt> -> while ( <exp> ) { <stmt_list> }
		<stmt> -> return <exp> ;

		<stmt> -> func_id ( <arg_list> ) ;

		// toto pravidlo a pravidlo podtím kolidují
		// v případě že se jedná o přiřazení výsledku volání funkce, syntaktický analyzátor sám o sobě, bez sémantické analýzy, 
		// nemůže rozpoznat rozdíl mezi těmito dvěmi pravidli, obě by byly namatchovány
		<stmt> -> $var_id =  func_id ( <arg_list> ) ;
		<stmt> -> $var_id =  <exp> ;
		// možnosti: přesunout zpracování přiřazení výsledku volání funkce do zpracování výrazů

		// pozn. je <exp>; výraz?, je to povoleno? -> kdyžtak další pravidlo <stmt> -> <exp> ;

			<arg_list> -> <arg> <arg_next> | e
			<arg_next> -> , <arg> <arg_next> | e

				<arg> -> $var_id | string_literal | integer_literal | float_literal | null
				// může být argument výraz nebo funkce s n8vratovou hodnotou f(g())

	<func> -> function func_id ( <param_list> ) : <return_type> { <stmt_list> }

		<param_list> -> <type> $var_id <param_next> | e
		<param_next> -> , <type> $var_id <param_next> | e

		<return_type> -> <type> | void

			<type> -> int | ?int | float | ?float | string | ?string
